## 编译
### 编译并运行服务器
```shell
cd server
go build
./server
#or
#./server :8088
```

### 编译并运行客户端
```shell
cd client
go build
./client
```
## client使用
### 启动时指定连接地址
```shell
./client -addr 127.0.0.1:8999
```
### 交互命令
client支持三种格式命令
- 功能性命令
	功能性命令格式为 `:command param1 param2`
- gm命令
	gm命令格式为 `/command param1 param2`
- 聊天
	除上述以外的所有命令

下面是详细说明
#### :login name password
玩家必须登陆后，才可以进行其他操作，密码不对无法登陆。
```shell
:login name password
```
#### :select room
玩家登陆后，默认进入房间1，可以通过select命令选择进入或创建新的房间
```shell
:select 10
```
#### /stats playerName
显示某个玩家的状态
```shell
/stats playerA
```
#### /popular room
```shell
/popular 1
```
#### 聊天
玩家聊天时，最大字符长度不能超过1024字节，并且目前支持英文的屏蔽字过滤。
## 性能
测试机器：MacBook Pro 2.2 GHz 四核Intel Core i7

测试方法：
- 在同一台机器上，启动一个服务器。
- 启动3个客户端，都登陆同一个room。
- 在其中一个客户端上，执行:bench 100 1000000

测试结果：timeCost=28100ms,sendCount=1000000,qps=35000

结果分析：
- 因为时间关系，客户端和服务器在同一机器上测试，所以压测结果不能表明服务器的实际qps，理想情况下应该都分开部署，同时使client的性能大于server为佳。
- 测试用例不足，未测试多种数据以及不同client同时压测的极限情况。
- 在性能测试过程中，观察cpu基本全部跑满，其中user%占%50左右，%sys占%40左右，没达到100%是因为还有其他进程有影响。
- 同时观察，发现网络的开销巨大，并且server和client的上下文和系统调用非常多，这也是sys占%40的主要原因，流量太大。

## 核心实现
### 网络框架
- 核心的网络框架，采用的是基于事件，结合多协程+主协程的工作模式。
- 其中，主协程是一个事件框架，其核心任务是不断读取事件、处理，不断循环。
- 另有许多个子协程，处理各个socket的io事件,其收到io后，负责将网络信息进行预处理（判断包是否损坏，是否有效）,然后将其封装成一个事件，放到事件框架中，等待时间框架后面处理。
- 全局的管理器（playerMgr、roomMgr）只会被主协程调用，这样各个协程之间没有锁的顾虑，事件框架和网络协程交互式，通过channel交互。

### 消息解析
- 消息体本身使用json序列化
- 在发送消息体时，添加包头，依次是
	- 4个字节的魔数`chat`
	- 2字节的正包长度
	- 2个字节的消息类型
	- 实际数据
- 在接受消息时，同样根据顺序，依次解析并还原数据
- 最后根据消息类型，调用不同的处理方法。

### 屏蔽词过滤
- 首先是读取屏蔽词库表，然后生成一个tire树。
- 然后，在收到聊天请求后，首先对原文进行分割，根据字符',','.',' '来简单分割成多个单词，然后利用词树查询该单词最大可匹配的长度，如果不为0，则进行"*"替换。
### 最近10分钟频率最高的词
- 每个房间内，保存有一个单词数组，其保存了内容、发送时间。
- 每次在添加新的单词时和查询高频词时，都会先进行判断，从前往后，删除掉已超过10分钟的单词。
- 查询时，首先利用map，遍历一遍单词数组，记录下每个单词出现的频率，然后遍历map，找出最大频率的词。